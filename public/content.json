{"meta":{"title":"Yu","subtitle":"Jarrem","description":"僧侣所修之道，即为禅定之道，非禅不智，非智不禅の","author":"Yu","url":"https://tangshiyu.github.io","root":"/"},"pages":[{"title":"关于","date":"2020-02-17T09:13:29.748Z","updated":"2020-02-17T09:13:29.748Z","comments":false,"path":"about/index.html","permalink":"https://tangshiyu.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2018-05-30T15:48:37.000Z","updated":"2020-02-17T09:13:29.752Z","comments":false,"path":"categories/index.html","permalink":"https://tangshiyu.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-02-17T09:13:29.754Z","updated":"2020-02-17T09:13:29.754Z","comments":false,"path":"tags/index.html","permalink":"https://tangshiyu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Golang 中的 goroutine 简单理解和使用","slug":"Go/goroutine/goroutine","date":"2020-02-16T02:22:56.000Z","updated":"2020-02-18T03:24:44.085Z","comments":true,"path":"2020/02/16/Go/goroutine/goroutine/","link":"","permalink":"https://tangshiyu.github.io/2020/02/16/Go/goroutine/goroutine/","excerpt":"","text":"什么是goroutine相关概念 进程 进程是系统进行资源分配的和调度的基本单元，具有独立功能的程序在某个数据集合上的一次执行过程 线程 ​ 线程是进程的一个执行实体或者执行单元，是比进程更小的且能独立运行的基本单元，一个进程至少会有一个线程 协程 协程又被称作为微协程，纤程。 协程相对独立有自己的上下文，由线程拉起，和线程相比协程避免了无意义的调度因此提高了性能，协程相对线程而言节约的是CPU的切换时间，但需要开发人员自己通过代码去调度kong goroutine ​ goroutine是Go语言的协程实现，从调度上讲goroutine的调度开销远远小于线程调度开销，不同的是Go在runtime和系统调用等方面对goroutine做了封装处理，goroutine不完全是受开发人员控制，一定程度上由Go runtime管理, 当某个goroutine受阻塞时，会让出CPU资源给其他的goroutine, Golang 的一大特色就是从语言层面原生支持协程，在函数或者方法前面加 go关键字就可创建一个协程。 CSP并发模型​ 这里简单介绍下CSP，后面专门写一篇详细介绍CSP模型, CSP(communicating sequential processes)它不同与多线程通过共享内存来通信，像Java中共享内存通信时需要考虑线程安全问题,原子性、有序性、可见性。CSP模型讲究的是通过通信来共享内存，这也是Go语言特有的并发模型，CSP模型主要通过Go的goroutine和channel来实现。 GPM模型这里也是简单了解和介绍，后面将详细介绍 G: Goroutine ，本质上一种轻量级的线程 P: Processor, 代表了M所需要上下文环境，处理用户级代码逻辑的处理器，这里是一个抽象的概念并非真正的CPU，当P有任务时需要创建或者唤醒一个系统线程来执行它队列里面任务，所以需要P与M的绑定形成一个执行单元 M: Machine, 关联系统的一个内核线程，每次创建一个M时候都会有一个底层线程创建，所有的G任务最后都是在G上面运行 它们之间的关系如下： ​ 一个M(Machine)对应一个系统内核线程，也会连接一个上下文P(Processor)，一个上下文P会关联多个G(Goroutine ) goroutine实际应用​ Go的并发写起来非常容器不像其他语言，只需要一个go关键字就可以搞定，例如:go work(), 在启动一个goroutine，一定需要知道它时何时关闭的，并且要节约使用，考虑它的必要性避免滥用，使用goroutine会给程序带来风险特别是死锁，对于后面问题排除也会带来很大的麻烦 sync.WaitGroup​ 当我们启动一个goroutine时候，我们必须考虑它何时结束，但运行时间较长的时候，不做任何操作，这时候如果main主进程运行结束，会导致进程直接退出，不会考虑启动的goroutine有没有结束，甚至可能goroutine还没有起来，main已经运行完了，有必要的时候需要等待启动的goroutine运行完再退出，有人可能马上想到用sleep的方式，sleep不能准确估计goroutine运行时间，甚至可能会导致进程一直卡住，这里我们需要一个管理者，这个管理者就是sync.WaitGroup 案例代码如下: 1234567891011121314151617181920212223242526package mainimport ( \"fmt\" \"sync\" \"time\")func work(data int) &#123; fmt.Println(data) time.Sleep(time.Duration(1) * time.Second)&#125;func main() &#123; gNum := 5 var wg = sync.WaitGroup&#123;&#125; wg.Add(gNum) for i := 1; i &lt;= gNum; i++ &#123; go func(w sync.WaitGroup, data int) &#123; work(data) wg.Done() &#125;(wg, i) &#125; wg.Wait()&#125; 运行结果如下: 123456751243Process finished with exit code 0 使用的时候一定要保证设置等待的goroutine，最后一定要Done关闭掉不然就会导致死锁 使用channel传递信息 channle一定得小心使用，一定不要滥用，channel使用不当很容器造成死锁，并且channel使用注意以下几点 不能往关闭的channle发消息 不能只发消息或者不能只接受消息，只在单一的goroutine里操作无缓冲信道，一定会死锁，例如下面代码中的订阅者，如果不加超时机制，如果发布者关闭或者退出了订阅者等待的消息永远等不到就会造成死锁 两个通道依赖使用,一个通道的输出作为另外一个通道的输入，例如c1&lt;-&lt;-c2，这个很容易造成两个goroutine等待变成死锁 简单的发布订阅通过channel实现如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package mainimport ( \"fmt\" \"sync\" \"time\")// 简单的发布订阅，通过channel实现type Publisher struct &#123; PubMsg chan string StopSignal chan bool&#125;// 发布者func publish(p Publisher, w *sync.WaitGroup) &#123; duration := time.Duration(1) * time.Second tick := time.NewTicker(duration) var msgCnt = 0 defer func() &#123; fmt.Println(\"publisher will exit.......\") tick.Stop() w.Done() &#125;() for &#123; select &#123; case &lt;-tick.C: // 每秒发布一条消息 p.PubMsg &lt;- fmt.Sprintf(\"消息-%d\", msgCnt) msgCnt++ // 这里模拟关闭发布者 if msgCnt &gt;= 5 &#123; return &#125; case &lt;-p.StopSignal: fmt.Println(\"收到停止发送信号,将关闭publish...\") return &#125; &#125;&#125;// 订阅者func subscriber(p Publisher, w *sync.WaitGroup) &#123; d := time.Duration(2) * time.Second timeout := time.NewTimer(d) defer func() &#123; fmt.Println(\"subscriber will exit.......\") timeout.Stop() w.Done() &#125;() for &#123; select &#123; case msg := &lt;-p.PubMsg: fmt.Printf(\"收到订阅消息:%s\\n\", msg) timeout.Reset(d) // 设置收取消息超时防止死锁 case &lt;-timeout.C: fmt.Println(\"收取消息超时!!!\") return &#125; &#125;&#125;func main() &#123; // 消息通道 msgChan := make(chan string) // 停止信号通道 singleChan := make(chan bool) publisher := Publisher&#123;msgChan, singleChan&#125; wg := &amp;sync.WaitGroup&#123;&#125; wg.Add(2) go publish(publisher, wg) go subscriber(publisher, wg) wg.Wait()&#125; 总结goroutine本质是协程，也是Go实现并行的核心，用起来比较简单，但是用好它不太容易，使用时一定要设计好，考虑是否一定要用它。","categories":[{"name":"Go","slug":"Go","permalink":"https://tangshiyu.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://tangshiyu.github.io/tags/Go/"}]},{"title":"代理模式","slug":"设计模式/代理模式/proxy","date":"2020-02-15T02:08:40.000Z","updated":"2020-02-17T09:13:29.736Z","comments":true,"path":"2020/02/15/设计模式/代理模式/proxy/","link":"","permalink":"https://tangshiyu.github.io/2020/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/proxy/","excerpt":"","text":"​ 代理模式为其他对象提供一种代理以控制对这个对象的访问权限，它主要解决直接访问对象带来的问题，例如公司环境访问通过堡垒机代理访问生产环境权限，避免了生成环境权限全部开发的局面，只需要开放相应的权限给开发者即可，注意它不需要更改原始接口的内容 ​ 例如下面堡垒机，在原始虚拟机VM上做权限控制和审计功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package mainimport ( \"errors\" \"fmt\")// 原始虚拟机拥有读写和执行权限type VM struct &#123;&#125;func (vm *VM) Write() &#123; fmt.Println(\"Permission to write....\")&#125;func (vm *VM) Read() &#123; fmt.Println(\"Permission to Read.....\")&#125;func (vm *VM) execute() &#123; fmt.Println(\"Permission to execute.....\")&#125;// 堡垒机type AccessGateway struct &#123; v *VM&#125;// 堡垒机可以做相关权限控制,和审计功能func NewAccessGateWay(username string) (*AccessGateway, error) &#123; if username != \"Yu\" &#123; return nil, errors.New(\"Username not enough permissions\") &#125; fmt.Printf(\"[%s] login into access gate wasy......\\n\", username) return &amp;AccessGateway&#123;&amp;VM&#123;&#125;&#125;, nil&#125;func (ag *AccessGateway) Read() &#123; ag.v.Read()&#125;func (ag *AccessGateway) Write() &#123; ag.v.Write()&#125;func main() &#123; var accessGateway, err = NewAccessGateWay(\"Yu\") if err != nil &#123; fmt.Printf(\"Login into access gateway meet err! %v\", err) return &#125; accessGateway.Write() accessGateway.Read()&#125; 输出结果如下: 12345[Yu] login into access gate wasy......Permission to write....Permission to Read.....Process finished with exit code 0","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://tangshiyu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://tangshiyu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"单例模式","slug":"设计模式/单例模式/singleton","date":"2020-02-13T04:08:40.000Z","updated":"2020-02-17T09:13:29.739Z","comments":true,"path":"2020/02/13/设计模式/单例模式/singleton/","link":"","permalink":"https://tangshiyu.github.io/2020/02/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/singleton/","excerpt":"","text":"单例模式是我们平常开发中用的最多设计模式之一，单例有很多级别上的，例如函数上的单例，进程上的单例，下面讲的是代码中的单例，只要了解单例的思想即可，语言知识实现工具，下面讲解如下几种类型单例模式 饿汉模式 懒汉模式 懒汉模式(加锁) 懒汉模式(双重检查加锁) sync.Once实现 相关代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import ( \"fmt\" \"sync\")type SingleTon struct &#123;&#125;var singleTon *SingleTonvar mu sync.Mutex//懒汉模式//还有一种饿汉式，就是一开始就初始化singleTon,实现如下//func init() &#123;// singleTon = &amp;SingleTon&#123;&#125;//&#125;func NewSingleTon() *SingleTon &#123; if singleTon == nil &#123; singleTon = &amp;SingleTon&#123;&#125; &#125; return singleTon&#125;// 懒汉加锁func NewSingleTonByLock() *SingleTon &#123; mu.Lock() defer mu.Unlock() if singleTon == nil &#123; singleTon = &amp;SingleTon&#123;&#125; &#125; return singleTon&#125;// 懒汉加检查锁func NewSingleTonByLock2() *SingleTon &#123; if singleTon == nil &#123; mu.Lock() defer mu.Unlock() if singleTon == nil &#123; singleTon = &amp;SingleTon&#123;&#125; &#125; &#125; return singleTon&#125;// 通过sync.Once实现// 看过Once包的知道，实现很简单通过加锁实现，通过done标记位来判断，运行过一次通过原子操作将done置为1var once sync.Oncefunc NewSingleTonByOnce() *SingleTon &#123; once.Do(func() &#123; singleTon = &amp;SingleTon&#123;&#125; &#125;) return singleTon&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://tangshiyu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://tangshiyu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}]}