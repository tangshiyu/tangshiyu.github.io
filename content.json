{"meta":{"title":"Yu","subtitle":"Jarrem","description":"僧侣所修之道，即为禅定之道，非禅不智，非智不禅の","author":"Yu","url":"https://tangshiyu.github.io","root":"/"},"pages":[{"title":"关于","date":"2020-02-14T03:33:00.169Z","updated":"2020-02-10T11:17:25.289Z","comments":false,"path":"about/index.html","permalink":"https://tangshiyu.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"标签","date":"2020-02-11T02:40:14.244Z","updated":"2020-02-11T02:40:14.244Z","comments":false,"path":"tags/index.html","permalink":"https://tangshiyu.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-05-30T15:48:37.000Z","updated":"2020-02-11T02:29:13.170Z","comments":false,"path":"categories/index.html","permalink":"https://tangshiyu.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"单例模式","slug":"设计模式/单例模式/singleton","date":"2020-02-13T04:08:40.000Z","updated":"2020-02-14T08:41:11.832Z","comments":true,"path":"2020/02/13/设计模式/单例模式/singleton/","link":"","permalink":"https://tangshiyu.github.io/2020/02/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/singleton/","excerpt":"","text":"单例模式是我们平常开发中用的最多设计模式之一，单例有很多级别上的，例如函数上的单例，进程上的单例，下面讲的是代码中的单例，只要了解单例的思想即可，语言知识实现工具，下面讲解如下几种类型单例模式 饿汉模式 懒汉模式 懒汉模式(加锁) 懒汉模式(双重检查加锁) sync.Once实现 相关代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import ( \"fmt\" \"sync\")type SingleTon struct &#123;&#125;var singleTon *SingleTonvar mu sync.Mutex//懒汉模式//还有一种饿汉式，就是一开始就初始化singleTon,实现如下//func init() &#123;// singleTon = &amp;SingleTon&#123;&#125;//&#125;func NewSingleTon() *SingleTon &#123; if singleTon == nil &#123; singleTon = &amp;SingleTon&#123;&#125; &#125; return singleTon&#125;// 懒汉加锁func NewSingleTonByLock() *SingleTon &#123; mu.Lock() defer mu.Unlock() if singleTon == nil &#123; singleTon = &amp;SingleTon&#123;&#125; &#125; return singleTon&#125;// 懒汉加检查锁func NewSingleTonByLock2() *SingleTon &#123; if singleTon == nil &#123; mu.Lock() defer mu.Unlock() if singleTon == nil &#123; singleTon = &amp;SingleTon&#123;&#125; &#125; &#125; return singleTon&#125;// 通过sync.Once实现// 看过Once包的知道，实现很简单通过加锁实现，通过done标记位来判断，运行过一次通过原子操作将done置为1var once sync.Oncefunc NewSingleTonByOnce() *SingleTon &#123; once.Do(func() &#123; singleTon = &amp;SingleTon&#123;&#125; &#125;) return singleTon&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://tangshiyu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://tangshiyu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}]}