{"meta":{"title":"Yu","subtitle":"Jarrem","description":"僧侣所修之道，即为禅定之道，非禅不智，非智不禅の","author":"Yu","url":"https://tangshiyu.github.io","root":"/"},"pages":[{"title":"关于","date":"2020-02-15T02:48:28.093Z","updated":"2020-02-15T02:48:28.093Z","comments":false,"path":"about/index.html","permalink":"https://tangshiyu.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"标签","date":"2020-02-15T02:48:28.097Z","updated":"2020-02-15T02:48:28.097Z","comments":false,"path":"tags/index.html","permalink":"https://tangshiyu.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-05-30T15:48:37.000Z","updated":"2020-02-15T02:48:28.095Z","comments":false,"path":"categories/index.html","permalink":"https://tangshiyu.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Golang 中的 goroutine 理解","slug":"Go/goroutine/goroutine","date":"2020-02-16T02:22:56.000Z","updated":"2020-02-16T03:26:29.880Z","comments":true,"path":"2020/02/16/Go/goroutine/goroutine/","link":"","permalink":"https://tangshiyu.github.io/2020/02/16/Go/goroutine/goroutine/","excerpt":"","text":"[toc] Goroutine什么是goroutine相关概念 进程 进程是系统进行资源分配的和调度的基本单元，具有独立功能的程序在某个数据集合上的一次执行过程 线程 ​ 线程是进程的一个执行实体或者执行单元，是比进程更小的且能独立运行的基本单元，一个进程至少会有一个线程 协程 协程又被称作为微协程，纤程。 协程相对独立有自己的上下文，由线程拉起，和线程相比协程避免了无意义的调度因此提高了性能，协程相对线程而言节约的是CPU的切换时间，但需要开发人员自己通过代码去调度 goroutine与它们的区别 CSP并发模型GPM模型goroutine实际应用00 使用wg00 使用channel传递信息00 sync.Pool##","categories":[{"name":"Go","slug":"Go","permalink":"https://tangshiyu.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://tangshiyu.github.io/tags/Go/"}]},{"title":"代理模式","slug":"设计模式/代理模式/proxy","date":"2020-02-15T02:08:40.000Z","updated":"2020-02-15T02:48:28.086Z","comments":true,"path":"2020/02/15/设计模式/代理模式/proxy/","link":"","permalink":"https://tangshiyu.github.io/2020/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/proxy/","excerpt":"","text":"​ 代理模式为其他对象提供一种代理以控制对这个对象的访问权限，它主要解决直接访问对象带来的问题，例如公司环境访问通过堡垒机代理访问生产环境权限，避免了生成环境权限全部开发的局面，只需要开放相应的权限给开发者即可，注意它不需要更改原始接口的内容 ​ 例如下面堡垒机，在原始虚拟机VM上做权限控制和审计功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package mainimport ( \"errors\" \"fmt\")// 原始虚拟机拥有读写和执行权限type VM struct &#123;&#125;func (vm *VM) Write() &#123; fmt.Println(\"Permission to write....\")&#125;func (vm *VM) Read() &#123; fmt.Println(\"Permission to Read.....\")&#125;func (vm *VM) execute() &#123; fmt.Println(\"Permission to execute.....\")&#125;// 堡垒机type AccessGateway struct &#123; v *VM&#125;// 堡垒机可以做相关权限控制,和审计功能func NewAccessGateWay(username string) (*AccessGateway, error) &#123; if username != \"Yu\" &#123; return nil, errors.New(\"Username not enough permissions\") &#125; fmt.Printf(\"[%s] login into access gate wasy......\\n\", username) return &amp;AccessGateway&#123;&amp;VM&#123;&#125;&#125;, nil&#125;func (ag *AccessGateway) Read() &#123; ag.v.Read()&#125;func (ag *AccessGateway) Write() &#123; ag.v.Write()&#125;func main() &#123; var accessGateway, err = NewAccessGateWay(\"Yu\") if err != nil &#123; fmt.Printf(\"Login into access gateway meet err! %v\", err) return &#125; accessGateway.Write() accessGateway.Read()&#125; 输出结果如下: 12345[Yu] login into access gate wasy......Permission to write....Permission to Read.....Process finished with exit code 0","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://tangshiyu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://tangshiyu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"单例模式","slug":"设计模式/单例模式/singleton","date":"2020-02-13T04:08:40.000Z","updated":"2020-02-15T02:48:28.088Z","comments":true,"path":"2020/02/13/设计模式/单例模式/singleton/","link":"","permalink":"https://tangshiyu.github.io/2020/02/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/singleton/","excerpt":"","text":"单例模式是我们平常开发中用的最多设计模式之一，单例有很多级别上的，例如函数上的单例，进程上的单例，下面讲的是代码中的单例，只要了解单例的思想即可，语言知识实现工具，下面讲解如下几种类型单例模式 饿汉模式 懒汉模式 懒汉模式(加锁) 懒汉模式(双重检查加锁) sync.Once实现 相关代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import ( \"fmt\" \"sync\")type SingleTon struct &#123;&#125;var singleTon *SingleTonvar mu sync.Mutex//懒汉模式//还有一种饿汉式，就是一开始就初始化singleTon,实现如下//func init() &#123;// singleTon = &amp;SingleTon&#123;&#125;//&#125;func NewSingleTon() *SingleTon &#123; if singleTon == nil &#123; singleTon = &amp;SingleTon&#123;&#125; &#125; return singleTon&#125;// 懒汉加锁func NewSingleTonByLock() *SingleTon &#123; mu.Lock() defer mu.Unlock() if singleTon == nil &#123; singleTon = &amp;SingleTon&#123;&#125; &#125; return singleTon&#125;// 懒汉加检查锁func NewSingleTonByLock2() *SingleTon &#123; if singleTon == nil &#123; mu.Lock() defer mu.Unlock() if singleTon == nil &#123; singleTon = &amp;SingleTon&#123;&#125; &#125; &#125; return singleTon&#125;// 通过sync.Once实现// 看过Once包的知道，实现很简单通过加锁实现，通过done标记位来判断，运行过一次通过原子操作将done置为1var once sync.Oncefunc NewSingleTonByOnce() *SingleTon &#123; once.Do(func() &#123; singleTon = &amp;SingleTon&#123;&#125; &#125;) return singleTon&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://tangshiyu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://tangshiyu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}]}